<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>TruthVector Drift Canvas — v0.1</title>
<style>
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 1.5rem; line-height: 1.45; }
  h1 { margin-top: 0; }
  .grid3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem; }
  textarea { width: 100%; min-height: 180px; }
  .card { border:1px solid #ddd; border-radius:8px; padding:1rem; background:#fff; }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
  .small { font-size: 0.9rem; color: #333; }
  .pill { display:inline-block; padding: 0.15rem 0.5rem; border-radius: 999px; font-size: 0.8rem; border:1px solid #999; margin-right: 0.4rem; }
  .shared { background:#eef8ef; border-color:#66aa66; }
  .drift { background:#fff4e5; border-color:#cc8800; }
  .uniq { background:#f8eef1; border-color:#aa6688; }
  .bar { display:flex; gap:0.5rem; flex-wrap:wrap; margin:0.5rem 0; }
  .btn { padding: 0.55rem 0.9rem; border: 1px solid #999; background: #f5f5f5; cursor: pointer; border-radius: 6px; }
  .btn:active { transform: translateY(1px); }
  .row { margin: 0.6rem 0; }
  pre { white-space: pre-wrap; }
  .muted { color:#666; }
</style>
</head>
<body>
<h1>TruthVector Drift Canvas — v0.1</h1>
<p class="muted">Paste outputs from three models. We treat divergence as signal. Classify lines, keep the gold, export a sealed synthesis.</p>

<div class="grid3">
  <div class="card">
    <h3>Model A</h3>
    <input id="nameA" placeholder="Name/version (e.g., Gemini Research 2.0)" style="width:100%; margin-bottom:0.3rem;">
    <textarea id="textA"></textarea>
  </div>
  <div class="card">
    <h3>Model B</h3>
    <input id="nameB" placeholder="Name/version (e.g., Claude 3.7 Sonnet)" style="width:100%; margin-bottom:0.3rem;">
    <textarea id="textB"></textarea>
  </div>
  <div class="card">
    <h3>Model C</h3>
    <input id="nameC" placeholder="Name/version (e.g., DeepSeek R1)" style="width:100%; margin-bottom:0.3rem;">
    <textarea id="textC"></textarea>
  </div>
</div>

<div class="card">
  <h3>Compare</h3>
  <div class="bar">
    <button class="btn" id="analyzeBtn">Analyze</button>
    <button class="btn" id="downloadJsonBtn">Download .json</button>
    <button class="btn" id="downloadTxtBtn">Download Synthesis .txt</button>
  </div>
  <div id="stats" class="small mono"></div>
  <div id="report" class="small"></div>
</div>

<div class="card">
  <h3>Synthesis (you edit)</h3>
  <textarea id="synth" class="mono" placeholder="Draft a synthesis that keeps valuable drift."></textarea>
  <div class="bar">
    <button class="btn" id="hashBtn">Compute SHA‑384</button>
    <span class="small">!SHA384=<span id="hash" class="mono"></span></span>
  </div>
</div>

<script>
function splitSentences(t){
  // Very simple splitter: split by line breaks and sentence punctuation.
  return t.replace(/\r\n/g,"\n").split(/(?<=[.!?])\s+|\n+/).map(s=>s.trim()).filter(Boolean);
}
function words(s){
  return s.toLowerCase().replace(/[^a-z0-9\s]/g," ").split(/\s+/).filter(Boolean);
}
function jaccard(a,b){
  const A = new Set(a), B = new Set(b);
  const inter = new Set([...A].filter(x=>B.has(x))).size;
  const union = new Set([...A, ...B]).size || 1;
  return inter/union;
}
function analyze(){
  const Aname = document.getElementById("nameA").value.trim();
  const Bname = document.getElementById("nameB").value.trim();
  const Cname = document.getElementById("nameC").value.trim();
  const A = splitSentences(document.getElementById("textA").value);
  const B = splitSentences(document.getElementById("textB").value);
  const C = splitSentences(document.getElementById("textC").value);
  const sets = [A,B,C].map(sents=>sents.map(words));
  // Build a catalog: each sentence in A/B/C finds best match in the others
  function bestMatch(s, pool){
    let best = {score:0, idx:-1};
    const sw = words(s);
    pool.forEach((t, i)=>{
      const sc = jaccard(sw, words(t));
      if (sc>best.score) best = {score:sc, idx:i};
    });
    return best;
  }
  // Tag sentences from the union of all
  const items = [];
  function pushAll(srcIdx, name, arr, others){
    arr.forEach((s, i)=>{
      const bm1 = bestMatch(s, others[0]);
      const bm2 = bestMatch(s, others[1]);
      const shared = (bm1.score>=0.55) + (bm2.score>=0.55); // how many others roughly agree
      items.push({src:srcIdx, model:name, text:s, agree:shared, matchScores:[bm1.score,bm2.score]});
    });
  }
  pushAll(0, Aname||"A", A, [B,C]);
  pushAll(1, Bname||"B", B, [A,C]);
  pushAll(2, Cname||"C", C, [A,B]);
  // Simple buckets
  const shared = items.filter(it=>it.agree>=1);
  const drift = items.filter(it=>it.agree===0);
  // Stats
  const stats = `A:${A.length} B:${B.length} C:${C.length} | shared(≥1 match): ${shared.length} | drift(unique): ${drift.length}`;
  document.getElementById("stats").textContent = stats;
  // Render report
  function esc(s){ return s.replace(/[&<>]/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[ch])); }
  let html = "";
  html += `<div class="pill shared">Consensus (≥1 match)</div> <div class="pill drift">Drift (unique)</div><hr>`;
  html += `<h4>Consensus candidates</h4>`;
  html += shared.slice(0,200).map(it=>`<div class="shared pill">${esc(it.model)}</div> ${esc(it.text)}<br>`).join("");
  html += `<h4>Drift candidates (inspect for gold)</h4>`;
  html += drift.slice(0,300).map(it=>`<div class="drift pill">${esc(it.model)}</div> ${esc(it.text)}<br>`).join("");
  document.getElementById("report").innerHTML = html;
  return {Aname,Bname,Cname,A,B,C,items};
}
async function sha384Hex(str) {
  const enc = new TextEncoder();
  const buf = await crypto.subtle.digest("SHA-384", enc.encode(str));
  const arr = Array.from(new Uint8Array(buf));
  return arr.map(b => b.toString(16).padStart(2, "0")).join("");
}
function download(name, text) {
  const blob = new Blob([text], {type: "application/json;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = name; document.body.appendChild(a); a.click();
  document.body.removeChild(a); URL.revokeObjectURL(url);
}
document.getElementById("analyzeBtn").addEventListener("click", analyze);
document.getElementById("downloadJsonBtn").addEventListener("click", ()=>{
  const res = analyze();
  const data = {
    meta: {tool:"TruthVector Drift Canvas v0.1", timestamp:new Date().toISOString()},
    models: {A:res.Aname, B:res.Bname, C:res.Cname},
    counts: {A:res.A.length, B:res.B.length, C:res.C.length},
    items: res.items
  };
  const ts = new Date().toISOString().replace(/[:.]/g, "").slice(0,15) + "Z";
  download(`TruthVector_DriftCanvas_${ts}.json`, JSON.stringify(data, null, 2));
});
document.getElementById("downloadTxtBtn").addEventListener("click", ()=>{
  const synth = document.getElementById("synth").value.trim();
  const ts = new Date().toISOString().replace(/[:.]/g, "").slice(0,15) + "Z";
  const txt = `!BEGIN DRIFT SYNTHESIS\n${synth}\n!END DRIFT SYNTHESIS\n`;
  const blob = new Blob([txt], {type: "text/plain;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = `TruthVector_Synthesis_${ts}.txt`; document.body.appendChild(a); a.click();
  document.body.removeChild(a); URL.revokeObjectURL(url);
});
document.getElementById("hashBtn").addEventListener("click", async ()=>{
  const synth = document.getElementById("synth").value.replace(/\r\n/g,"\n").trim() + "\n";
  const hex = await sha384Hex(synth);
  document.getElementById("hash").textContent = hex;
});
</script>
</body>
</html>